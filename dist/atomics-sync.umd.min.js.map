{"version":3,"file":"atomics-sync.umd.min.js","sources":["../es/errors.js","../es/limits.js","../es/mutex.js","../es/semaphore.js","../es/condition.js","../es/barrier.js","../es/spinlock.js","../es/once.js"],"sourcesContent":["export class DeadlockError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"DeadlockError\";\n    }\n}\nexport class PermissionError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"PermissionError\";\n    }\n}\nexport class InvalidError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"InvalidError\";\n    }\n}\n//# sourceMappingURL=errors.js.map","export const INT32_MAX_VALUE = 2147483647;\nexport const INT32_MIN_VALUE = -2147483648;\n//# sourceMappingURL=limits.js.map","import { DeadlockError, InvalidError, PermissionError } from \"./errors.js\";\nimport { INT32_MAX_VALUE, INT32_MIN_VALUE } from \"./limits.js\";\nconst { compareExchange, wait, notify, store, load } = Atomics;\nexport class Mutex {\n    static init() {\n        const mutex = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 2));\n        store(mutex, Mutex.INDEX_STATE, Mutex.STATE_UNLOCKED);\n        store(mutex, Mutex.INDEX_OWNER, Mutex.OWNER_EMPTY);\n        return mutex;\n    }\n    static lock(mutex, threadId) {\n        Mutex.checkThreadIdBeforeLock(mutex, threadId);\n        for (;;) {\n            if (compareExchange(mutex, Mutex.INDEX_STATE, Mutex.STATE_UNLOCKED, Mutex.STATE_LOCKED) === Mutex.STATE_UNLOCKED) {\n                store(mutex, Mutex.INDEX_OWNER, threadId);\n                return;\n            }\n            wait(mutex, Mutex.INDEX_STATE, Mutex.STATE_LOCKED);\n        }\n    }\n    static timedLock(mutex, threadId, timestamp) {\n        Mutex.checkThreadIdBeforeLock(mutex, threadId);\n        for (;;) {\n            if (compareExchange(mutex, Mutex.INDEX_STATE, Mutex.STATE_UNLOCKED, Mutex.STATE_LOCKED) === Mutex.STATE_UNLOCKED) {\n                store(mutex, Mutex.INDEX_OWNER, threadId);\n                return true;\n            }\n            const timeout = timestamp - Date.now();\n            const waitResult = wait(mutex, Mutex.INDEX_STATE, Mutex.STATE_LOCKED, timeout);\n            if (waitResult === \"timed-out\") {\n                return false;\n            }\n        }\n    }\n    static tryLock(mutex, threadId) {\n        Mutex.checkThreadIdBeforeLock(mutex, threadId);\n        if (compareExchange(mutex, Mutex.INDEX_STATE, Mutex.STATE_UNLOCKED, Mutex.STATE_LOCKED) === Mutex.STATE_UNLOCKED) {\n            store(mutex, Mutex.INDEX_OWNER, threadId);\n            return true;\n        }\n        return false;\n    }\n    static unlock(mutex, threadId) {\n        Mutex.checkThreadIdIsValid(threadId);\n        if (load(mutex, Mutex.INDEX_OWNER) !== threadId) {\n            throw new PermissionError(\"current thread is not owner of mutex\");\n        }\n        if (compareExchange(mutex, Mutex.INDEX_STATE, Mutex.STATE_LOCKED, Mutex.STATE_UNLOCKED) === Mutex.STATE_UNLOCKED) {\n            throw new PermissionError(\"mutex was not locked\");\n        }\n        store(mutex, Mutex.INDEX_OWNER, Mutex.OWNER_EMPTY);\n        notify(mutex, Mutex.INDEX_STATE, 1);\n    }\n    static checkThreadIdBeforeLock(mutex, threadId) {\n        Mutex.checkThreadIdIsValid(threadId);\n        if (load(mutex, Mutex.INDEX_OWNER) === threadId) {\n            throw new DeadlockError(\"thread already owns this mutex\");\n        }\n    }\n    static checkThreadIdIsValid(threadId) {\n        if (!Number.isInteger(threadId)) {\n            throw new InvalidError(\"threadId should be int32\");\n        }\n        if (threadId < INT32_MIN_VALUE || threadId > INT32_MAX_VALUE) {\n            throw new RangeError(\"threadId is out of int32 range\");\n        }\n        if (threadId === Mutex.OWNER_EMPTY) {\n            throw new InvalidError(\"threadId is empty owner\");\n        }\n    }\n}\nMutex.OWNER_EMPTY = 0;\nMutex.STATE_UNLOCKED = 0;\nMutex.STATE_LOCKED = 1;\nMutex.INDEX_STATE = 0;\nMutex.INDEX_OWNER = 1;\n//# sourceMappingURL=mutex.js.map","import { InvalidError } from \"./errors.js\";\nimport { INT32_MAX_VALUE } from \"./limits.js\";\nconst { compareExchange, wait, notify, store, load } = Atomics;\nexport class Semaphore {\n    static init(value) {\n        if (!Number.isInteger(value)) {\n            throw new InvalidError(\"initial value should be int32\");\n        }\n        if (value < 0 || value > INT32_MAX_VALUE) {\n            throw new RangeError(\"initial value should be greater or equal zero and less or equal maximum int32 value\");\n        }\n        const sem = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT));\n        store(sem, Semaphore.INDEX_VALUE, value);\n        return sem;\n    }\n    static wait(sem) {\n        for (;;) {\n            const value = load(sem, Semaphore.INDEX_VALUE);\n            if (value > 0) {\n                if (compareExchange(sem, Semaphore.INDEX_VALUE, value, value - 1) === value) {\n                    return;\n                }\n            }\n            else {\n                wait(sem, Semaphore.INDEX_VALUE, value);\n            }\n        }\n    }\n    static timedWait(sem, timestamp) {\n        for (;;) {\n            const value = load(sem, Semaphore.INDEX_VALUE);\n            if (value > 0) {\n                if (compareExchange(sem, Semaphore.INDEX_VALUE, value, value - 1) === value) {\n                    return true;\n                }\n            }\n            else {\n                const timeout = timestamp - Date.now();\n                const waitResult = wait(sem, Semaphore.INDEX_VALUE, value, timeout);\n                if (waitResult === \"timed-out\") {\n                    return false;\n                }\n            }\n        }\n    }\n    static tryWait(sem) {\n        for (;;) {\n            const value = load(sem, Semaphore.INDEX_VALUE);\n            if (value === 0) {\n                return false;\n            }\n            if (compareExchange(sem, Semaphore.INDEX_VALUE, value, value - 1) === value) {\n                return true;\n            }\n        }\n    }\n    static post(sem) {\n        for (;;) {\n            const value = load(sem, Semaphore.INDEX_VALUE);\n            if (value === INT32_MAX_VALUE) {\n                throw new RangeError(\"maximum limit reached for semaphore value\");\n            }\n            if (compareExchange(sem, Semaphore.INDEX_VALUE, value, value + 1) === value) {\n                if (value === 0) {\n                    notify(sem, Semaphore.INDEX_VALUE, 1);\n                }\n                return;\n            }\n        }\n    }\n    static getValue(sem) {\n        return load(sem, Semaphore.INDEX_VALUE);\n    }\n}\nSemaphore.INDEX_VALUE = 0;\n//# sourceMappingURL=semaphore.js.map","import { Mutex } from \"./mutex\";\nconst { wait, notify } = Atomics;\nexport class Condition {\n    static init() {\n        return new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT));\n    }\n    static signal(cond) {\n        notify(cond, 0, 1);\n    }\n    static broadcast(cond) {\n        notify(cond, 0);\n    }\n    static wait(cond, mutex, threadId) {\n        Mutex.unlock(mutex, threadId);\n        wait(cond, 0, 0);\n        Mutex.lock(mutex, threadId);\n    }\n    static timedWait(cond, mutex, threadId, timestamp) {\n        try {\n            Mutex.unlock(mutex, threadId);\n            return wait(cond, 0, 0, timestamp - Date.now()) !== \"timed-out\";\n        }\n        finally {\n            Mutex.lock(mutex, threadId);\n        }\n    }\n}\n//# sourceMappingURL=condition.js.map","import { Condition } from \"./condition\";\nimport { InvalidError } from \"./errors\";\nimport { Mutex } from \"./mutex\";\nconst { store, load, add } = Atomics;\nexport class Barrier {\n    static init(count) {\n        Barrier.validateCount(count);\n        const barrier = new BigInt64Array(new SharedArrayBuffer(BigInt64Array.BYTES_PER_ELEMENT * 3));\n        store(barrier, Barrier.INDEX_COUNT, BigInt(count));\n        store(barrier, Barrier.INDEX_WAITED, 0n);\n        store(barrier, Barrier.INDEX_GENERATION, 0n);\n        const mutex = Mutex.init();\n        const cond = Condition.init();\n        return {\n            barrier,\n            mutex,\n            cond\n        };\n    }\n    static wait(barrier, threadId) {\n        Mutex.lock(barrier.mutex, threadId);\n        const generation = load(barrier.barrier, Barrier.INDEX_GENERATION);\n        const count = load(barrier.barrier, Barrier.INDEX_COUNT);\n        const waited = add(barrier.barrier, Barrier.INDEX_WAITED, 1n) + 1n;\n        try {\n            if (waited >= count) {\n                store(barrier.barrier, Barrier.INDEX_WAITED, 0n);\n                add(barrier.barrier, Barrier.INDEX_GENERATION, 1n);\n                Condition.broadcast(barrier.cond);\n                return true;\n            }\n            while (load(barrier.barrier, Barrier.INDEX_GENERATION) === generation) {\n                Condition.wait(barrier.cond, barrier.mutex, threadId);\n            }\n            return false;\n        }\n        finally {\n            Mutex.unlock(barrier.mutex, threadId);\n        }\n    }\n    static validateCount(count) {\n        if (!Number.isInteger(count)) {\n            throw new InvalidError(\"count should be integer\");\n        }\n        if (count <= 0) {\n            throw new RangeError(\"count should be greater zero\");\n        }\n    }\n}\nBarrier.INDEX_COUNT = 0;\nBarrier.INDEX_WAITED = 1;\nBarrier.INDEX_GENERATION = 2;\n//# sourceMappingURL=barrier.js.map","import { DeadlockError, InvalidError, PermissionError } from \"./errors.js\";\nimport { INT32_MAX_VALUE, INT32_MIN_VALUE } from \"./limits.js\";\nconst { compareExchange, store, load } = Atomics;\nexport class SpinLock {\n    static init() {\n        const lock = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 2));\n        store(lock, SpinLock.INDEX_STATE, SpinLock.STATE_UNLOCKED);\n        store(lock, SpinLock.INDEX_OWNER, SpinLock.OWNER_EMPTY);\n        return lock;\n    }\n    static lock(lock, threadId) {\n        SpinLock.checkThreadIdBeforeLock(lock, threadId);\n        for (;;) {\n            if (compareExchange(lock, SpinLock.INDEX_STATE, SpinLock.STATE_UNLOCKED, SpinLock.STATE_LOCKED) ===\n                SpinLock.STATE_UNLOCKED) {\n                store(lock, SpinLock.INDEX_OWNER, threadId);\n                return;\n            }\n            // @ts-ignore\n            if (typeof Atomics.pause === \"function\") {\n                // @ts-ignore\n                Atomics.pause();\n            }\n        }\n    }\n    static tryLock(lock, threadId) {\n        SpinLock.checkThreadIdBeforeLock(lock, threadId);\n        if (compareExchange(lock, SpinLock.INDEX_STATE, SpinLock.STATE_UNLOCKED, SpinLock.STATE_LOCKED) ===\n            SpinLock.STATE_UNLOCKED) {\n            store(lock, SpinLock.INDEX_OWNER, threadId);\n            return true;\n        }\n        return false;\n    }\n    static unlock(lock, threadId) {\n        SpinLock.checkThreadIdIsValid(threadId);\n        if (load(lock, SpinLock.INDEX_OWNER) !== threadId) {\n            throw new PermissionError(\"current thread is not owner of lock\");\n        }\n        if (compareExchange(lock, SpinLock.INDEX_STATE, SpinLock.STATE_LOCKED, SpinLock.STATE_UNLOCKED) ===\n            SpinLock.STATE_UNLOCKED) {\n            throw new PermissionError(\"lock was not locked\");\n        }\n        store(lock, SpinLock.INDEX_OWNER, SpinLock.OWNER_EMPTY);\n    }\n    static checkThreadIdBeforeLock(lock, threadId) {\n        SpinLock.checkThreadIdIsValid(threadId);\n        if (load(lock, SpinLock.INDEX_OWNER) === threadId) {\n            throw new DeadlockError(\"thread already owns this lock\");\n        }\n    }\n    static checkThreadIdIsValid(threadId) {\n        if (!Number.isInteger(threadId)) {\n            throw new InvalidError(\"threadId should be int32\");\n        }\n        if (threadId < INT32_MIN_VALUE || threadId > INT32_MAX_VALUE) {\n            throw new RangeError(\"threadId is out of int32 range\");\n        }\n        if (threadId === SpinLock.OWNER_EMPTY) {\n            throw new InvalidError(\"threadId is empty owner\");\n        }\n    }\n}\nSpinLock.OWNER_EMPTY = 0;\nSpinLock.STATE_UNLOCKED = 0;\nSpinLock.STATE_LOCKED = 1;\nSpinLock.INDEX_STATE = 0;\nSpinLock.INDEX_OWNER = 1;\n//# sourceMappingURL=spinlock.js.map","const { compareExchange, store } = Atomics;\nexport class Once {\n    static init() {\n        const once = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT));\n        store(once, Once.INDEX_EXECUTED, Once.EXECUTED_NO);\n        return once;\n    }\n    static execute(once, fn) {\n        if (compareExchange(once, Once.INDEX_EXECUTED, Once.EXECUTED_NO, Once.EXECUTED_YES) === Once.EXECUTED_NO) {\n            fn();\n        }\n    }\n    static isExecuted(once) {\n        return Atomics.load(once, Once.INDEX_EXECUTED) === Once.EXECUTED_YES;\n    }\n}\nOnce.INDEX_EXECUTED = 0;\nOnce.EXECUTED_NO = 0;\nOnce.EXECUTED_YES = 1;\n//# sourceMappingURL=once.js.map"],"names":["DeadlockError","Error","constructor","message","super","this","name","PermissionError","InvalidError","INT32_MAX_VALUE","INT32_MIN_VALUE","compareExchange","wait","notify","store","load","Atomics","Mutex","init","mutex","Int32Array","SharedArrayBuffer","BYTES_PER_ELEMENT","INDEX_STATE","STATE_UNLOCKED","INDEX_OWNER","OWNER_EMPTY","lock","threadId","checkThreadIdBeforeLock","STATE_LOCKED","timedLock","timestamp","timeout","Date","now","tryLock","unlock","checkThreadIdIsValid","Number","isInteger","RangeError","Semaphore","value","sem","INDEX_VALUE","timedWait","tryWait","post","getValue","Condition","signal","cond","broadcast","add","Barrier","count","validateCount","barrier","BigInt64Array","INDEX_COUNT","BigInt","INDEX_WAITED","INDEX_GENERATION","generation","waited","SpinLock","pause","Once","once","INDEX_EXECUTED","EXECUTED_NO","execute","fn","EXECUTED_YES","isExecuted"],"mappings":"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"}