{"version":3,"file":"atomics-sync.cjs.js","sources":["../es/errors.js","../es/limits.js","../es/mutex.js","../es/semaphore.js","../es/condition.js","../es/barrier.js","../es/spinlock.js","../es/once.js"],"sourcesContent":["/**\n * Error thrown when a deadlock situation is detected in synchronization primitives.\n * This typically occurs when threads are circularly waiting for resources/locks\n * held by each other.\n */\nexport class DeadlockError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"DeadlockError\";\n    }\n}\n/**\n * Error thrown when a thread attempts an operation it doesn't have permission for,\n * such as unlocking a mutex it doesn't own or accessing protected resources.\n */\nexport class PermissionError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"PermissionError\";\n    }\n}\n/**\n * Error thrown when invalid arguments or operations are detected,\n * such as passing non-integer values where integers are required,\n * or attempting operations on improperly initialized objects.\n */\nexport class InvalidError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"InvalidError\";\n    }\n}\n//# sourceMappingURL=errors.js.map","/**\n * The maximum safe 32-bit signed integer value (2^31 - 1).\n * This is the largest value that can be stored in an Int32Array or similar typed array.\n * Useful for boundary checking in integer operations.\n */\nexport const INT32_MAX_VALUE = 2147483647;\n/**\n * The minimum safe 32-bit signed integer value (-2^31).\n * This is the smallest value that can be stored in an Int32Array or similar typed array.\n * Useful for boundary checking in integer operations.\n */\nexport const INT32_MIN_VALUE = -2147483648;\n//# sourceMappingURL=limits.js.map","import { DeadlockError, InvalidError, PermissionError } from \"./errors.js\";\nimport { INT32_MAX_VALUE, INT32_MIN_VALUE } from \"./limits.js\";\nconst { compareExchange, wait, notify, store, load } = Atomics;\n/**\n * A mutual exclusion lock implementation for thread synchronization.\n * Uses SharedArrayBuffer and Atomics for cross-thread operations.\n * Provides basic lock/unlock functionality with additional timed and try variants.\n * Tracks owning thread to prevent deadlocks and enforce proper usage.\n */\nexport class Mutex {\n    /**\n     * Initializes a new mutex in shared memory\n     * @returns A new Int32Array backed by SharedArrayBuffer with:\n     *          - index 0: state (initially unlocked)\n     *          - index 1: owner (initially empty)\n     */\n    static init() {\n        const mutex = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 2));\n        store(mutex, Mutex.INDEX_STATE, Mutex.STATE_UNLOCKED);\n        store(mutex, Mutex.INDEX_OWNER, Mutex.OWNER_EMPTY);\n        return mutex;\n    }\n    /**\n     * Acquires the mutex, blocking until available\n     * @param mutex The mutex to lock\n     * @param threadId Unique identifier for the calling thread\n     * @throws {DeadlockError} If thread already owns the mutex\n     * @throws {InvalidError} If threadId is invalid\n     */\n    static lock(mutex, threadId) {\n        Mutex.checkThreadIdBeforeLock(mutex, threadId);\n        // Spin-wait loop with atomic compare-exchange\n        for (;;) {\n            // Attempt atomic acquisition\n            if (compareExchange(mutex, Mutex.INDEX_STATE, Mutex.STATE_UNLOCKED, Mutex.STATE_LOCKED) === Mutex.STATE_UNLOCKED) {\n                store(mutex, Mutex.INDEX_OWNER, threadId);\n                return;\n            }\n            // Wait efficiently if mutex is locked\n            wait(mutex, Mutex.INDEX_STATE, Mutex.STATE_LOCKED);\n        }\n    }\n    /**\n     * Attempts to acquire the mutex with a timeout\n     * @param mutex The mutex to lock\n     * @param threadId Unique identifier for the calling thread\n     * @param timestamp Absolute timeout timestamp in milliseconds\n     * @returns true if lock acquired, false if timed out\n     * @throws {DeadlockError} If thread already owns the mutex\n     * @throws {InvalidError} If threadId is invalid\n     */\n    static timedLock(mutex, threadId, timestamp) {\n        Mutex.checkThreadIdBeforeLock(mutex, threadId);\n        for (;;) {\n            if (compareExchange(mutex, Mutex.INDEX_STATE, Mutex.STATE_UNLOCKED, Mutex.STATE_LOCKED) === Mutex.STATE_UNLOCKED) {\n                store(mutex, Mutex.INDEX_OWNER, threadId);\n                return true;\n            }\n            const timeout = timestamp - Date.now();\n            const waitResult = wait(mutex, Mutex.INDEX_STATE, Mutex.STATE_LOCKED, timeout);\n            if (waitResult === \"timed-out\") {\n                return false;\n            }\n        }\n    }\n    /**\n     * Attempts to acquire the mutex without blocking\n     * @param mutex The mutex to lock\n     * @param threadId Unique identifier for the calling thread\n     * @returns true if lock acquired, false if mutex was busy\n     * @throws {DeadlockError} If thread already owns the mutex\n     * @throws {InvalidError} If threadId is invalid\n     */\n    static tryLock(mutex, threadId) {\n        Mutex.checkThreadIdBeforeLock(mutex, threadId);\n        if (compareExchange(mutex, Mutex.INDEX_STATE, Mutex.STATE_UNLOCKED, Mutex.STATE_LOCKED) === Mutex.STATE_UNLOCKED) {\n            store(mutex, Mutex.INDEX_OWNER, threadId);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Releases the mutex\n     * @param mutex The mutex to unlock\n     * @param threadId Unique identifier for the calling thread\n     * @throws {PermissionError} If thread doesn't own the mutex or mutex wasn't locked\n     * @throws {InvalidError} If threadId is invalid\n     */\n    static unlock(mutex, threadId) {\n        Mutex.checkThreadIdIsValid(threadId);\n        // Verify ownership\n        if (load(mutex, Mutex.INDEX_OWNER) !== threadId) {\n            throw new PermissionError(\"current thread is not owner of mutex\");\n        }\n        // Clear owner first to prevent race conditions\n        store(mutex, Mutex.INDEX_OWNER, Mutex.OWNER_EMPTY);\n        // Verify locked state while unlocking\n        if (compareExchange(mutex, Mutex.INDEX_STATE, Mutex.STATE_LOCKED, Mutex.STATE_UNLOCKED) === Mutex.STATE_UNLOCKED) {\n            throw new PermissionError(\"mutex was not locked\");\n        }\n        // Wake one waiting thread\n        notify(mutex, Mutex.INDEX_STATE, 1);\n    }\n    /**\n     * Validates threadId and checks for deadlock conditions before locking\n     * @param mutex The mutex being locked\n     * @param threadId The thread attempting to lock\n     * @throws {DeadlockError} If thread already owns mutex\n     * @throws {InvalidError} If threadId is invalid\n     */\n    static checkThreadIdBeforeLock(mutex, threadId) {\n        Mutex.checkThreadIdIsValid(threadId);\n        if (load(mutex, Mutex.INDEX_OWNER) === threadId) {\n            throw new DeadlockError(\"thread already owns this mutex\");\n        }\n    }\n    /**\n     * Validates that a threadId is properly formatted and within range\n     * @param threadId The thread ID to validate\n     * @throws {InvalidError} If threadId is not an integer or is empty\n     * @throws {RangeError} If threadId is outside int32 range\n     */\n    static checkThreadIdIsValid(threadId) {\n        if (!Number.isInteger(threadId)) {\n            throw new InvalidError(\"threadId should be int32\");\n        }\n        if (threadId < INT32_MIN_VALUE || threadId > INT32_MAX_VALUE) {\n            throw new RangeError(\"threadId is out of int32 range\");\n        }\n        if (threadId === Mutex.OWNER_EMPTY) {\n            throw new InvalidError(\"threadId is empty owner\");\n        }\n    }\n}\n// Constants for mutex state management\nMutex.OWNER_EMPTY = 0; // Value indicating no owner\nMutex.STATE_UNLOCKED = 0; // Mutex is available\nMutex.STATE_LOCKED = 1; // Mutex is acquired\nMutex.INDEX_STATE = 0; // Index for state in array\nMutex.INDEX_OWNER = 1; // Index for owner in array\n//# sourceMappingURL=mutex.js.map","import { InvalidError } from \"./errors.js\";\nimport { INT32_MAX_VALUE } from \"./limits.js\";\nconst { compareExchange, wait, notify, store, load } = Atomics;\n/**\n * A counting semaphore implementation for thread synchronization.\n * Controls access to shared resources with a counter that atomically tracks available permits.\n * Supports blocking, timed, and non-blocking acquisition of permits.\n */\nexport class Semaphore {\n    /**\n     * Initializes a new semaphore with the specified initial value\n     * @param value Initial number of available permits (must be non-negative integer)\n     * @returns A new Int32Array backed by SharedArrayBuffer\n     * @throws {InvalidError} If value is not an integer\n     * @throws {RangeError} If value is negative or exceeds INT32_MAX_VALUE\n     */\n    static init(value) {\n        if (!Number.isInteger(value)) {\n            throw new InvalidError(\"initial value should be int32\");\n        }\n        if (value < 0 || value > INT32_MAX_VALUE) {\n            throw new RangeError(\"initial value should be greater or equal zero and less or equal maximum int32 value\");\n        }\n        const sem = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT));\n        store(sem, Semaphore.INDEX_VALUE, value);\n        return sem;\n    }\n    /**\n     * Acquires a permit, blocking until one is available\n     * @param sem The semaphore to wait on\n     * @remarks\n     * - Uses atomic compare-exchange to safely decrement counter\n     * - Efficiently waits when no permits are available\n     */\n    static wait(sem) {\n        for (;;) {\n            const value = load(sem, Semaphore.INDEX_VALUE);\n            if (value > 0) {\n                if (compareExchange(sem, Semaphore.INDEX_VALUE, value, value - 1) === value) {\n                    return;\n                }\n            }\n            else {\n                wait(sem, Semaphore.INDEX_VALUE, value);\n            }\n        }\n    }\n    /**\n     * Attempts to acquire a permit with a timeout\n     * @param sem The semaphore to wait on\n     * @param timestamp Absolute timeout timestamp in milliseconds\n     * @returns true if permit acquired, false if timed out\n     */\n    static timedWait(sem, timestamp) {\n        for (;;) {\n            const value = load(sem, Semaphore.INDEX_VALUE);\n            if (value > 0) {\n                if (compareExchange(sem, Semaphore.INDEX_VALUE, value, value - 1) === value) {\n                    return true;\n                }\n            }\n            else {\n                const timeout = timestamp - Date.now();\n                const waitResult = wait(sem, Semaphore.INDEX_VALUE, value, timeout);\n                if (waitResult === \"timed-out\") {\n                    return false;\n                }\n            }\n        }\n    }\n    /**\n     * Attempts to acquire a permit without blocking\n     * @param sem The semaphore to try\n     * @returns true if permit was acquired, false if no permits available\n     */\n    static tryWait(sem) {\n        for (;;) {\n            const value = load(sem, Semaphore.INDEX_VALUE);\n            if (value === 0) {\n                return false;\n            }\n            if (compareExchange(sem, Semaphore.INDEX_VALUE, value, value - 1) === value) {\n                return true;\n            }\n        }\n    }\n    /**\n     * Releases a permit back to the semaphore\n     * @param sem The semaphore to post to\n     * @throws {RangeError} If incrementing would exceed INT32_MAX_VALUE\n     * @remarks Wakes one waiting thread if counter transitions from 0 to 1\n     */\n    static post(sem) {\n        for (;;) {\n            const value = load(sem, Semaphore.INDEX_VALUE);\n            if (value === INT32_MAX_VALUE) {\n                throw new RangeError(\"maximum limit reached for semaphore value\");\n            }\n            if (compareExchange(sem, Semaphore.INDEX_VALUE, value, value + 1) === value) {\n                if (value === 0) {\n                    notify(sem, Semaphore.INDEX_VALUE, 1);\n                }\n                return;\n            }\n        }\n    }\n    /**\n     * Gets the current number of available permits\n     * @param sem The semaphore to check\n     * @returns Current semaphore value (number of available permits)\n     */\n    static getValue(sem) {\n        return load(sem, Semaphore.INDEX_VALUE);\n    }\n}\n// Index for the value in the shared array\nSemaphore.INDEX_VALUE = 0;\n//# sourceMappingURL=semaphore.js.map","import { Mutex } from \"./mutex\";\nconst { wait, notify } = Atomics;\n/**\n * A condition variable implementation for thread synchronization.\n * Allows threads to wait for some condition to become true while properly releasing\n * and reacquiring a mutex lock. Uses SharedArrayBuffer for cross-thread communication.\n */\nexport class Condition {\n    /**\n     * Initializes a new condition variable in shared memory\n     * @returns A new Int32Array backed by SharedArrayBuffer\n     */\n    static init() {\n        return new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT));\n    }\n    /**\n     * Wakes up one thread waiting on the condition variable\n     * @param cond The condition variable to signal\n     */\n    static signal(cond) {\n        notify(cond, 0, 1);\n    }\n    /**\n     * Wakes up all threads waiting on the condition variable\n     * @param cond The condition variable to broadcast to\n     */\n    static broadcast(cond) {\n        notify(cond, 0);\n    }\n    /**\n     * Blocks the current thread until the condition variable is signaled\n     * @param cond The condition variable to wait on\n     * @param mutex The associated mutex to release while waiting\n     * @param threadId The ID of the current thread\n     * @remarks Automatically releases mutex before waiting and reacquires after\n     */\n    static wait(cond, mutex, threadId) {\n        Mutex.unlock(mutex, threadId);\n        wait(cond, 0, 0);\n        Mutex.lock(mutex, threadId);\n    }\n    /**\n     * Blocks the current thread until either:\n     * - The condition variable is signaled, or\n     * - The specified timeout expires\n     * @param cond The condition variable to wait on\n     * @param mutex The associated mutex to release while waiting\n     * @param threadId The ID of the current thread\n     * @param timestamp The absolute timeout timestamp in milliseconds\n     * @returns true if the condition was signaled, false if timed out\n     * @remarks Automatically releases mutex before waiting and reacquires after\n     */\n    static timedWait(cond, mutex, threadId, timestamp) {\n        try {\n            Mutex.unlock(mutex, threadId);\n            return wait(cond, 0, 0, timestamp - Date.now()) !== \"timed-out\";\n        }\n        finally {\n            Mutex.lock(mutex, threadId);\n        }\n    }\n}\n//# sourceMappingURL=condition.js.map","import { Condition } from \"./condition\";\nimport { InvalidError } from \"./errors\";\nimport { Mutex } from \"./mutex\";\nconst { store, load, add } = Atomics;\n/**\n * A synchronization primitive that enables multiple threads to wait for each other\n * to reach a common execution point before continuing.\n *\n * Implements a reusable barrier using shared memory, mutex and condition variable.\n */\nexport class Barrier {\n    /**\n     * Initializes a new barrier with the specified thread count\n     * @param count Number of threads that must reach the barrier before continuing\n     * @returns Initialized BarrierObject with shared structures\n     * @throws {InvalidError} If count is not an integer\n     * @throws {RangeError} If count is <= 0\n     */\n    static init(count) {\n        Barrier.validateCount(count);\n        const barrier = new BigInt64Array(new SharedArrayBuffer(BigInt64Array.BYTES_PER_ELEMENT * 3));\n        store(barrier, Barrier.INDEX_COUNT, BigInt(count));\n        store(barrier, Barrier.INDEX_WAITED, 0n);\n        store(barrier, Barrier.INDEX_GENERATION, 0n);\n        const mutex = Mutex.init();\n        const cond = Condition.init();\n        return {\n            barrier,\n            mutex,\n            cond\n        };\n    }\n    /**\n     * Makes the calling thread wait at the barrier until all threads have arrived\n     * @param barrier The barrier object to wait on\n     * @param threadId Unique identifier for the calling thread\n     * @returns true if this thread was the last to arrive (releases others), false otherwise\n     */\n    static wait(barrier, threadId) {\n        Mutex.lock(barrier.mutex, threadId);\n        const generation = load(barrier.barrier, Barrier.INDEX_GENERATION);\n        const count = load(barrier.barrier, Barrier.INDEX_COUNT);\n        const waited = add(barrier.barrier, Barrier.INDEX_WAITED, 1n) + 1n;\n        try {\n            if (waited >= count) {\n                store(barrier.barrier, Barrier.INDEX_WAITED, 0n);\n                add(barrier.barrier, Barrier.INDEX_GENERATION, 1n);\n                Condition.broadcast(barrier.cond);\n                return true;\n            }\n            while (load(barrier.barrier, Barrier.INDEX_GENERATION) === generation) {\n                Condition.wait(barrier.cond, barrier.mutex, threadId);\n            }\n            return false;\n        }\n        finally {\n            Mutex.unlock(barrier.mutex, threadId);\n        }\n    }\n    /**\n     * Validates that the thread count is a positive integer\n     * @param count Number to validate\n     * @throws {InvalidError} If count is not an integer\n     * @throws {RangeError} If count is <= 0\n     */\n    static validateCount(count) {\n        if (!Number.isInteger(count)) {\n            throw new InvalidError(\"count should be integer\");\n        }\n        if (count <= 0) {\n            throw new RangeError(\"count should be greater zero\");\n        }\n    }\n}\n// Indexes for accessing different values in the barrier array\nBarrier.INDEX_COUNT = 0; // Stores total threads required\nBarrier.INDEX_WAITED = 1; // Stores number of threads currently waiting\nBarrier.INDEX_GENERATION = 2; // Stores current barrier generation\n//# sourceMappingURL=barrier.js.map","import { DeadlockError, InvalidError, PermissionError } from \"./errors.js\";\nimport { INT32_MAX_VALUE, INT32_MIN_VALUE } from \"./limits.js\";\nconst { compareExchange, store, load } = Atomics;\n/**\n * A spin lock implementation for low-level thread synchronization.\n * Uses busy-waiting with atomic operations for acquiring the lock.\n * More efficient than mutexes for very short critical sections.\n * Tracks owning thread to prevent deadlocks and enforce proper usage.\n */\nexport class SpinLock {\n    /**\n     * Initializes a new spin lock in shared memory\n     * @returns A new Int32Array backed by SharedArrayBuffer with:\n     *          - index 0: state (initially unlocked)\n     *          - index 1: owner (initially empty)\n     */\n    static init() {\n        const lock = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 2));\n        store(lock, SpinLock.INDEX_STATE, SpinLock.STATE_UNLOCKED);\n        store(lock, SpinLock.INDEX_OWNER, SpinLock.OWNER_EMPTY);\n        return lock;\n    }\n    /**\n     * Acquires the lock, spinning until available\n     * @param lock The spin lock to acquire\n     * @param threadId Unique identifier for the calling thread\n     * @throws {DeadlockError} If thread already owns the lock\n     * @throws {InvalidError} If threadId is invalid\n     * @remarks Uses Atomics.pause() when available to reduce contention\n     */\n    static lock(lock, threadId) {\n        SpinLock.checkThreadIdBeforeLock(lock, threadId);\n        // Spin-wait loop with atomic compare-exchange\n        for (;;) {\n            // Attempt atomic acquisition\n            if (compareExchange(lock, SpinLock.INDEX_STATE, SpinLock.STATE_UNLOCKED, SpinLock.STATE_LOCKED) ===\n                SpinLock.STATE_UNLOCKED) {\n                store(lock, SpinLock.INDEX_OWNER, threadId);\n                return;\n            }\n            // Use pause instruction to reduce contention when available\n            // @ts-ignore\n            if (typeof Atomics.pause === \"function\") {\n                // @ts-ignore\n                Atomics.pause();\n            }\n        }\n    }\n    /**\n     * Attempts to acquire the lock without spinning\n     * @param lock The spin lock to try\n     * @param threadId Unique identifier for the calling thread\n     * @returns true if lock acquired, false if lock was busy\n     * @throws {DeadlockError} If thread already owns the lock\n     * @throws {InvalidError} If threadId is invalid\n     */\n    static tryLock(lock, threadId) {\n        SpinLock.checkThreadIdBeforeLock(lock, threadId);\n        if (compareExchange(lock, SpinLock.INDEX_STATE, SpinLock.STATE_UNLOCKED, SpinLock.STATE_LOCKED) ===\n            SpinLock.STATE_UNLOCKED) {\n            store(lock, SpinLock.INDEX_OWNER, threadId);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Releases the lock\n     * @param lock The spin lock to release\n     * @param threadId Unique identifier for the calling thread\n     * @throws {PermissionError} If thread doesn't own the lock or lock wasn't locked\n     * @throws {InvalidError} If threadId is invalid\n     */\n    static unlock(lock, threadId) {\n        SpinLock.checkThreadIdIsValid(threadId);\n        // Verify ownership\n        if (load(lock, SpinLock.INDEX_OWNER) !== threadId) {\n            throw new PermissionError(\"current thread is not owner of lock\");\n        }\n        // Clear owner first to prevent race conditions\n        store(lock, SpinLock.INDEX_OWNER, SpinLock.OWNER_EMPTY);\n        // Verify locked state while unlocking\n        if (compareExchange(lock, SpinLock.INDEX_STATE, SpinLock.STATE_LOCKED, SpinLock.STATE_UNLOCKED) ===\n            SpinLock.STATE_UNLOCKED) {\n            throw new PermissionError(\"lock was not locked\");\n        }\n    }\n    /**\n     * Validates threadId and checks for deadlock conditions before locking\n     * @param lock The spin lock being acquired\n     * @param threadId The thread attempting to lock\n     * @throws {DeadlockError} If thread already owns lock\n     * @throws {InvalidError} If threadId is invalid\n     */\n    static checkThreadIdBeforeLock(lock, threadId) {\n        SpinLock.checkThreadIdIsValid(threadId);\n        if (load(lock, SpinLock.INDEX_OWNER) === threadId) {\n            throw new DeadlockError(\"thread already owns this lock\");\n        }\n    }\n    /**\n     * Validates that a threadId is properly formatted and within range\n     * @param threadId The thread ID to validate\n     * @throws {InvalidError} If threadId is not an integer or is empty\n     * @throws {RangeError} If threadId is outside int32 range\n     */\n    static checkThreadIdIsValid(threadId) {\n        if (!Number.isInteger(threadId)) {\n            throw new InvalidError(\"threadId should be int32\");\n        }\n        if (threadId < INT32_MIN_VALUE || threadId > INT32_MAX_VALUE) {\n            throw new RangeError(\"threadId is out of int32 range\");\n        }\n        if (threadId === SpinLock.OWNER_EMPTY) {\n            throw new InvalidError(\"threadId is empty owner\");\n        }\n    }\n}\n// Constants for lock state management\nSpinLock.OWNER_EMPTY = 0; // Value indicating no owner\nSpinLock.STATE_UNLOCKED = 0; // Lock is available\nSpinLock.STATE_LOCKED = 1; // Lock is acquired\nSpinLock.INDEX_STATE = 0; // Index for state in array\nSpinLock.INDEX_OWNER = 1; // Index for owner in array\n//# sourceMappingURL=spinlock.js.map","const { compareExchange, store } = Atomics;\n/**\n * A synchronization primitive that ensures a function is executed only once,\n * even when called from multiple threads.\n * Uses atomic operations for thread-safe execution tracking.\n */\nexport class Once {\n    /**\n     * Initializes a new Once primitive in shared memory\n     * @returns A new Int32Array backed by SharedArrayBuffer initialized to NOT_EXECUTED\n     */\n    static init() {\n        const once = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT));\n        store(once, Once.INDEX_EXECUTED, Once.EXECUTED_NO);\n        return once;\n    }\n    /**\n     * Executes the provided function exactly once, even if called from multiple threads\n     * @param once The Once primitive to use for synchronization\n     * @param fn The function to execute (will be called at most once)\n     * @remarks The function will be called by whichever thread wins the atomic race\n     */\n    static execute(once, fn) {\n        if (compareExchange(once, Once.INDEX_EXECUTED, Once.EXECUTED_NO, Once.EXECUTED_YES) === Once.EXECUTED_NO) {\n            fn();\n        }\n    }\n    /**\n     * Checks if the function has been executed\n     * @param once The Once primitive to check\n     * @returns true if the function has been executed, false otherwise\n     */\n    static isExecuted(once) {\n        return Atomics.load(once, Once.INDEX_EXECUTED) === Once.EXECUTED_YES;\n    }\n}\n// Index for the execution state in the shared array\nOnce.INDEX_EXECUTED = 0;\n// Possible execution states\nOnce.EXECUTED_NO = 0; // Function has not been executed\nOnce.EXECUTED_YES = 1; // Function has been executed\n//# sourceMappingURL=once.js.map"],"names":["compareExchange","wait","notify","store","load"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACO,MAAM,aAAa,SAAS,KAAK,CAAC;AACzC,IAAI,WAAW,CAAC,OAAO,EAAE;AACzB,QAAQ,KAAK,CAAC,OAAO,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,IAAI,GAAG,eAAe,CAAC;AACpC,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACO,MAAM,eAAe,SAAS,KAAK,CAAC;AAC3C,IAAI,WAAW,CAAC,OAAO,EAAE;AACzB,QAAQ,KAAK,CAAC,OAAO,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,IAAI,GAAG,iBAAiB,CAAC;AACtC,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACO,MAAM,YAAY,SAAS,KAAK,CAAC;AACxC,IAAI,WAAW,CAAC,OAAO,EAAE;AACzB,QAAQ,KAAK,CAAC,OAAO,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,IAAI,GAAG,cAAc,CAAC;AACnC,KAAK;AACL;;AC/BA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC;;ACThC,MAAM,mBAAEA,iBAAe,QAAEC,MAAI,UAAEC,QAAM,SAAEC,OAAK,QAAEC,MAAI,EAAE,GAAG,OAAO,CAAC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,KAAK,CAAC;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,GAAG;AAClB,QAAQ,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,IAAI,iBAAiB,CAAC,UAAU,CAAC,iBAAiB,GAAG,CAAC,CAAC,CAAC,CAAC;AAC9F,QAAQD,OAAK,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,cAAc,CAAC,CAAC;AAC9D,QAAQA,OAAK,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;AAC3D,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,QAAQ,EAAE;AACjC,QAAQ,KAAK,CAAC,uBAAuB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AACvD;AACA,QAAQ,SAAS;AACjB;AACA,YAAY,IAAIH,iBAAe,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC,YAAY,CAAC,KAAK,KAAK,CAAC,cAAc,EAAE;AAC9H,gBAAgBG,OAAK,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;AAC1D,gBAAgB,OAAO;AACvB,aAAa;AACb;AACA,YAAYF,MAAI,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC;AAC/D,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,SAAS,CAAC,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE;AACjD,QAAQ,KAAK,CAAC,uBAAuB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AACvD,QAAQ,SAAS;AACjB,YAAY,IAAID,iBAAe,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC,YAAY,CAAC,KAAK,KAAK,CAAC,cAAc,EAAE;AAC9H,gBAAgBG,OAAK,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;AAC1D,gBAAgB,OAAO,IAAI,CAAC;AAC5B,aAAa;AACb,YAAY,MAAM,OAAO,GAAG,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;AACnD,YAAY,MAAM,UAAU,GAAGF,MAAI,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;AAC3F,YAAY,IAAI,UAAU,KAAK,WAAW,EAAE;AAC5C,gBAAgB,OAAO,KAAK,CAAC;AAC7B,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,OAAO,CAAC,KAAK,EAAE,QAAQ,EAAE;AACpC,QAAQ,KAAK,CAAC,uBAAuB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AACvD,QAAQ,IAAID,iBAAe,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC,YAAY,CAAC,KAAK,KAAK,CAAC,cAAc,EAAE;AAC1H,YAAYG,OAAK,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;AACtD,YAAY,OAAO,IAAI,CAAC;AACxB,SAAS;AACT,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,MAAM,CAAC,KAAK,EAAE,QAAQ,EAAE;AACnC,QAAQ,KAAK,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;AAC7C;AACA,QAAQ,IAAIC,MAAI,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,CAAC,KAAK,QAAQ,EAAE;AACzD,YAAY,MAAM,IAAI,eAAe,CAAC,sCAAsC,CAAC,CAAC;AAC9E,SAAS;AACT;AACA,QAAQD,OAAK,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;AAC3D;AACA,QAAQ,IAAIH,iBAAe,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,YAAY,EAAE,KAAK,CAAC,cAAc,CAAC,KAAK,KAAK,CAAC,cAAc,EAAE;AAC1H,YAAY,MAAM,IAAI,eAAe,CAAC,sBAAsB,CAAC,CAAC;AAC9D,SAAS;AACT;AACA,QAAQE,QAAM,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;AAC5C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,uBAAuB,CAAC,KAAK,EAAE,QAAQ,EAAE;AACpD,QAAQ,KAAK,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;AAC7C,QAAQ,IAAIE,MAAI,CAAC,KAAK,EAAE,KAAK,CAAC,WAAW,CAAC,KAAK,QAAQ,EAAE;AACzD,YAAY,MAAM,IAAI,aAAa,CAAC,gCAAgC,CAAC,CAAC;AACtE,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,oBAAoB,CAAC,QAAQ,EAAE;AAC1C,QAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAE;AACzC,YAAY,MAAM,IAAI,YAAY,CAAC,0BAA0B,CAAC,CAAC;AAC/D,SAAS;AACT,QAAQ,IAAI,QAAQ,GAAG,eAAe,IAAI,QAAQ,GAAG,eAAe,EAAE;AACtE,YAAY,MAAM,IAAI,UAAU,CAAC,gCAAgC,CAAC,CAAC;AACnE,SAAS;AACT,QAAQ,IAAI,QAAQ,KAAK,KAAK,CAAC,WAAW,EAAE;AAC5C,YAAY,MAAM,IAAI,YAAY,CAAC,yBAAyB,CAAC,CAAC;AAC9D,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC;AACtB,KAAK,CAAC,cAAc,GAAG,CAAC,CAAC;AACzB,KAAK,CAAC,YAAY,GAAG,CAAC,CAAC;AACvB,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC;AACtB,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC;;ACzItB,MAAM,mBAAEJ,iBAAe,QAAEC,MAAI,UAAEC,QAAM,SAAEC,OAAK,QAAEC,MAAI,EAAE,GAAG,OAAO,CAAC;AAC/D;AACA;AACA;AACA;AACA;AACO,MAAM,SAAS,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE;AACvB,QAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;AACtC,YAAY,MAAM,IAAI,YAAY,CAAC,+BAA+B,CAAC,CAAC;AACpE,SAAS;AACT,QAAQ,IAAI,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,eAAe,EAAE;AAClD,YAAY,MAAM,IAAI,UAAU,CAAC,qFAAqF,CAAC,CAAC;AACxH,SAAS;AACT,QAAQ,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,IAAI,iBAAiB,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC;AACxF,QAAQD,OAAK,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;AACjD,QAAQ,OAAO,GAAG,CAAC;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,CAAC,GAAG,EAAE;AACrB,QAAQ,SAAS;AACjB,YAAY,MAAM,KAAK,GAAGC,MAAI,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,CAAC,CAAC;AAC3D,YAAY,IAAI,KAAK,GAAG,CAAC,EAAE;AAC3B,gBAAgB,IAAIJ,iBAAe,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC,KAAK,KAAK,EAAE;AAC7F,oBAAoB,OAAO;AAC3B,iBAAiB;AACjB,aAAa;AACb,iBAAiB;AACjB,gBAAgBC,MAAI,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;AACxD,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,SAAS,CAAC,GAAG,EAAE,SAAS,EAAE;AACrC,QAAQ,SAAS;AACjB,YAAY,MAAM,KAAK,GAAGG,MAAI,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,CAAC,CAAC;AAC3D,YAAY,IAAI,KAAK,GAAG,CAAC,EAAE;AAC3B,gBAAgB,IAAIJ,iBAAe,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC,KAAK,KAAK,EAAE;AAC7F,oBAAoB,OAAO,IAAI,CAAC;AAChC,iBAAiB;AACjB,aAAa;AACb,iBAAiB;AACjB,gBAAgB,MAAM,OAAO,GAAG,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;AACvD,gBAAgB,MAAM,UAAU,GAAGC,MAAI,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;AACpF,gBAAgB,IAAI,UAAU,KAAK,WAAW,EAAE;AAChD,oBAAoB,OAAO,KAAK,CAAC;AACjC,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,OAAO,CAAC,GAAG,EAAE;AACxB,QAAQ,SAAS;AACjB,YAAY,MAAM,KAAK,GAAGG,MAAI,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,CAAC,CAAC;AAC3D,YAAY,IAAI,KAAK,KAAK,CAAC,EAAE;AAC7B,gBAAgB,OAAO,KAAK,CAAC;AAC7B,aAAa;AACb,YAAY,IAAIJ,iBAAe,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC,KAAK,KAAK,EAAE;AACzF,gBAAgB,OAAO,IAAI,CAAC;AAC5B,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,CAAC,GAAG,EAAE;AACrB,QAAQ,SAAS;AACjB,YAAY,MAAM,KAAK,GAAGI,MAAI,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,CAAC,CAAC;AAC3D,YAAY,IAAI,KAAK,KAAK,eAAe,EAAE;AAC3C,gBAAgB,MAAM,IAAI,UAAU,CAAC,2CAA2C,CAAC,CAAC;AAClF,aAAa;AACb,YAAY,IAAIJ,iBAAe,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC,KAAK,KAAK,EAAE;AACzF,gBAAgB,IAAI,KAAK,KAAK,CAAC,EAAE;AACjC,oBAAoBE,QAAM,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;AAC1D,iBAAiB;AACjB,gBAAgB,OAAO;AACvB,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,QAAQ,CAAC,GAAG,EAAE;AACzB,QAAQ,OAAOE,MAAI,CAAC,GAAG,EAAE,SAAS,CAAC,WAAW,CAAC,CAAC;AAChD,KAAK;AACL,CAAC;AACD;AACA,SAAS,CAAC,WAAW,GAAG,CAAC;;ACnHzB,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;AACjC;AACA;AACA;AACA;AACA;AACO,MAAM,SAAS,CAAC;AACvB;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,GAAG;AAClB,QAAQ,OAAO,IAAI,UAAU,CAAC,IAAI,iBAAiB,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC;AACnF,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,OAAO,MAAM,CAAC,IAAI,EAAE;AACxB,QAAQ,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3B,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,OAAO,SAAS,CAAC,IAAI,EAAE;AAC3B,QAAQ,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;AACxB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE;AACvC,QAAQ,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AACtC,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACzB,QAAQ,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE;AACvD,QAAQ,IAAI;AACZ,YAAY,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AAC1C,YAAY,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC,KAAK,WAAW,CAAC;AAC5E,SAAS;AACT,gBAAgB;AAChB,YAAY,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AACxC,SAAS;AACT,KAAK;AACL;;AC1DA,MAAM,SAAED,OAAK,QAAEC,MAAI,EAAE,GAAG,EAAE,GAAG,OAAO,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,OAAO,CAAC;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE;AACvB,QAAQ,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;AACrC,QAAQ,MAAM,OAAO,GAAG,IAAI,aAAa,CAAC,IAAI,iBAAiB,CAAC,aAAa,CAAC,iBAAiB,GAAG,CAAC,CAAC,CAAC,CAAC;AACtG,QAAQD,OAAK,CAAC,OAAO,EAAE,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3D,QAAQA,OAAK,CAAC,OAAO,EAAE,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;AACjD,QAAQA,OAAK,CAAC,OAAO,EAAE,OAAO,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC;AACrD,QAAQ,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;AACnC,QAAQ,MAAM,IAAI,GAAG,SAAS,CAAC,IAAI,EAAE,CAAC;AACtC,QAAQ,OAAO;AACf,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,IAAI;AAChB,SAAS,CAAC;AACV,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,CAAC,OAAO,EAAE,QAAQ,EAAE;AACnC,QAAQ,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AAC5C,QAAQ,MAAM,UAAU,GAAGC,MAAI,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,gBAAgB,CAAC,CAAC;AAC3E,QAAQ,MAAM,KAAK,GAAGA,MAAI,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;AACjE,QAAQ,MAAM,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,GAAG,EAAE,CAAC;AAC3E,QAAQ,IAAI;AACZ,YAAY,IAAI,MAAM,IAAI,KAAK,EAAE;AACjC,gBAAgBD,OAAK,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;AACjE,gBAAgB,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC;AACnE,gBAAgB,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AAClD,gBAAgB,OAAO,IAAI,CAAC;AAC5B,aAAa;AACb,YAAY,OAAOC,MAAI,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,gBAAgB,CAAC,KAAK,UAAU,EAAE;AACnF,gBAAgB,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AACtE,aAAa;AACb,YAAY,OAAO,KAAK,CAAC;AACzB,SAAS;AACT,gBAAgB;AAChB,YAAY,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AAClD,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,aAAa,CAAC,KAAK,EAAE;AAChC,QAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;AACtC,YAAY,MAAM,IAAI,YAAY,CAAC,yBAAyB,CAAC,CAAC;AAC9D,SAAS;AACT,QAAQ,IAAI,KAAK,IAAI,CAAC,EAAE;AACxB,YAAY,MAAM,IAAI,UAAU,CAAC,8BAA8B,CAAC,CAAC;AACjE,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA,OAAO,CAAC,WAAW,GAAG,CAAC,CAAC;AACxB,OAAO,CAAC,YAAY,GAAG,CAAC,CAAC;AACzB,OAAO,CAAC,gBAAgB,GAAG,CAAC,CAAC;;AC3E7B,MAAM,mBAAEJ,iBAAe,SAAEG,OAAK,EAAE,IAAI,EAAE,GAAG,OAAO,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,QAAQ,CAAC;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,GAAG;AAClB,QAAQ,MAAM,IAAI,GAAG,IAAI,UAAU,CAAC,IAAI,iBAAiB,CAAC,UAAU,CAAC,iBAAiB,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7F,QAAQA,OAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,cAAc,CAAC,CAAC;AACnE,QAAQA,OAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,WAAW,CAAC,CAAC;AAChE,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE;AAChC,QAAQ,QAAQ,CAAC,uBAAuB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACzD;AACA,QAAQ,SAAS;AACjB;AACA,YAAY,IAAIH,iBAAe,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,cAAc,EAAE,QAAQ,CAAC,YAAY,CAAC;AAC3G,gBAAgB,QAAQ,CAAC,cAAc,EAAE;AACzC,gBAAgBG,OAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;AAC5D,gBAAgB,OAAO;AACvB,aAAa;AACb;AACA;AACA,YAAY,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,UAAU,EAAE;AACrD;AACA,gBAAgB,OAAO,CAAC,KAAK,EAAE,CAAC;AAChC,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,OAAO,CAAC,IAAI,EAAE,QAAQ,EAAE;AACnC,QAAQ,QAAQ,CAAC,uBAAuB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACzD,QAAQ,IAAIH,iBAAe,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,cAAc,EAAE,QAAQ,CAAC,YAAY,CAAC;AACvG,YAAY,QAAQ,CAAC,cAAc,EAAE;AACrC,YAAYG,OAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;AACxD,YAAY,OAAO,IAAI,CAAC;AACxB,SAAS;AACT,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,MAAM,CAAC,IAAI,EAAE,QAAQ,EAAE;AAClC,QAAQ,QAAQ,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;AAChD;AACA,QAAQ,IAAI,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,CAAC,KAAK,QAAQ,EAAE;AAC3D,YAAY,MAAM,IAAI,eAAe,CAAC,qCAAqC,CAAC,CAAC;AAC7E,SAAS;AACT;AACA,QAAQA,OAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,WAAW,CAAC,CAAC;AAChE;AACA,QAAQ,IAAIH,iBAAe,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,YAAY,EAAE,QAAQ,CAAC,cAAc,CAAC;AACvG,YAAY,QAAQ,CAAC,cAAc,EAAE;AACrC,YAAY,MAAM,IAAI,eAAe,CAAC,qBAAqB,CAAC,CAAC;AAC7D,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,uBAAuB,CAAC,IAAI,EAAE,QAAQ,EAAE;AACnD,QAAQ,QAAQ,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;AAChD,QAAQ,IAAI,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,WAAW,CAAC,KAAK,QAAQ,EAAE;AAC3D,YAAY,MAAM,IAAI,aAAa,CAAC,+BAA+B,CAAC,CAAC;AACrE,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,oBAAoB,CAAC,QAAQ,EAAE;AAC1C,QAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAE;AACzC,YAAY,MAAM,IAAI,YAAY,CAAC,0BAA0B,CAAC,CAAC;AAC/D,SAAS;AACT,QAAQ,IAAI,QAAQ,GAAG,eAAe,IAAI,QAAQ,GAAG,eAAe,EAAE;AACtE,YAAY,MAAM,IAAI,UAAU,CAAC,gCAAgC,CAAC,CAAC;AACnE,SAAS;AACT,QAAQ,IAAI,QAAQ,KAAK,QAAQ,CAAC,WAAW,EAAE;AAC/C,YAAY,MAAM,IAAI,YAAY,CAAC,yBAAyB,CAAC,CAAC;AAC9D,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA,QAAQ,CAAC,WAAW,GAAG,CAAC,CAAC;AACzB,QAAQ,CAAC,cAAc,GAAG,CAAC,CAAC;AAC5B,QAAQ,CAAC,YAAY,GAAG,CAAC,CAAC;AAC1B,QAAQ,CAAC,WAAW,GAAG,CAAC,CAAC;AACzB,QAAQ,CAAC,WAAW,GAAG,CAAC,CAAC;;AC1HzB,MAAM,EAAE,eAAe,EAAE,KAAK,EAAE,GAAG,OAAO,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACO,MAAM,IAAI,CAAC;AAClB;AACA;AACA;AACA;AACA,IAAI,OAAO,IAAI,GAAG;AAClB,QAAQ,MAAM,IAAI,GAAG,IAAI,UAAU,CAAC,IAAI,iBAAiB,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC;AACzF,QAAQ,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;AAC3D,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,OAAO,CAAC,IAAI,EAAE,EAAE,EAAE;AAC7B,QAAQ,IAAI,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,YAAY,CAAC,KAAK,IAAI,CAAC,WAAW,EAAE;AAClH,YAAY,EAAE,EAAE,CAAC;AACjB,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,UAAU,CAAC,IAAI,EAAE;AAC5B,QAAQ,OAAO,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,IAAI,CAAC,YAAY,CAAC;AAC7E,KAAK;AACL,CAAC;AACD;AACA,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;AACxB;AACA,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;AACrB,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;;;;;;;;;;;;;;"}